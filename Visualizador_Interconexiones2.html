<!-- Chosen Palette: Indigo & Slate -->
<!-- Application Structure Plan: A single-purpose 2D canvas visualization tool, now expanded to support 12 pillars. The central pillar is defined by a URL parameter (e.g., "?pilar=11"), making the file dynamically reusable for all 12 pillars. If no parameter is provided, it defaults to pillar 1. This maintains its utility for linking from external documents. -->
<!-- Visualization & Content Choices: 
- Network Diagram -> Goal: Inform/Explain -> Method: 2D Canvas drawing -> Interaction: None (static image generation) -> Justification: Provides a clear, reproducible visual aid. The structure dynamically adapts to the new data model with 12 nodes.
-->
<!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizador de Interconexiones - ESTRATEGO SIG</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://rsms.me/inter/inter.css');
        body { font-family: 'Inter', sans-serif; background-color: #f8fafc; }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl bg-white p-6 rounded-xl shadow-lg text-center">
        <h1 id="diagram-title" class="text-2xl font-bold text-indigo-700 mb-2"></h1>
        <p class="text-slate-600 mb-4">Este diagrama muestra las conexiones directas del pilar central dentro del ecosistema ESTRATEGO SIG.</p>
        <canvas id="connection-canvas" width="800" height="600" class="mx-auto border rounded-lg"></canvas>
        <div id="instructions" class="mt-4 text-sm text-slate-500">
            <!-- Instructions will be populated by script -->
        </div>
    </div>

<script>
    const urlParams = new URLSearchParams(window.location.search);
    const pilarIdFromUrl = parseInt(urlParams.get('pilar'), 10);
    
    const centralPillarId = (pilarIdFromUrl >= 1 && pilarIdFromUrl <= 12) ? pilarIdFromUrl : 1;

    const pilaresData = [
        { id: 1, name: "Humano", color: "#22c55e", connections: [2, 6, 8, 4, 10] },
        { id: 2, name: "Procesos", color: "#3b82f6", connections: [1, 6, 8, 4, 12] },
        { id: 3, name: "Personalización", color: "#a855f7", connections: [4, 5, 9, 12] },
        { id: 4, name: "IA", color: "#ec4899", connections: [1, 2, 3, 6, 12] },
        { id: 5, name: "Prospectivo", color: "#f59e0b", connections: [3, 7, 8, 9, 10, 11] },
        { id: 6, name: "Operacional", color: "#14b8a6", connections: [1, 2, 7, 4, 11, 12] },
        { id: 7, name: "Planning", color: "#06b6d4", connections: [5, 6, 8, 11] },
        { id: 8, name: "Project Mgmt", color: "#ef4444", connections: [1, 2, 5, 7, 9, 10, 11] },
        { id: 9, name: "Cliente & Mercado", color: "#f472b6", connections: [3, 5, 8] },
        { id: 10, name: "Estrategias", color: "#84cc16", connections: [1, 5, 8] },
        { id: 11, name: "Presupuesto", color: "#6366f1", connections: [5, 6, 7, 8] },
        { id: 12, name: "Ciberseguridad", color: "#64748b", connections: [2, 3, 4, 6] }
    ];

    const canvas = document.getElementById('connection-canvas');
    const ctx = canvas.getContext('2d');
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    const centralPilar = pilaresData.find(p => p.id === centralPillarId);
    if (centralPilar) {
        document.getElementById('diagram-title').textContent = `Mapa de Interconexión del Pilar: ${centralPilar.name}`;
        if (!pilarIdFromUrl) {
            document.getElementById('instructions').innerHTML = `<strong>Instrucción:</strong> Estás viendo el pilar por defecto. Para ver otro, añade <strong>?pilar=N</strong> al final de la URL (donde N es el número del pilar).`;
        }
        drawNetwork();
    }

    function drawNode(x, y, radius, color, text, isCentral = false, isConnected = false) {
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI, false);
        
        if (isCentral) {
            ctx.fillStyle = color;
            ctx.shadowColor = 'rgba(0,0,0,0.2)';
            ctx.shadowBlur = 15;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 5;
        } else if (isConnected) {
            ctx.fillStyle = color;
             ctx.shadowColor = 'rgba(0,0,0,0.1)';
            ctx.shadowBlur = 10;
        } else {
            ctx.fillStyle = '#e2e8f0';
        }
        
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.shadowColor = 'transparent';

        ctx.strokeStyle = isConnected || isCentral ? '#475569' : '#94a3b8';
        ctx.lineWidth = isCentral ? 4 : (isConnected ? 2 : 1);
        ctx.stroke();

        // Split text for multi-line display
        const lines = text.split('\n');
        const lineHeight = 16;
        const startY = y - (lines.length - 1) * lineHeight / 2;

        ctx.fillStyle = isCentral || isConnected ? 'white' : '#64748b';
        ctx.font = isCentral ? 'bold 16px Inter' : 'bold 14px Inter';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        lines.forEach((line, index) => {
            ctx.fillText(line, x, startY + index * lineHeight);
        });
    }

    function drawLine(x1, y1, x2, y2) {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = '#94a3b8';
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    function drawNetwork() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const positions = {};
        const connectedPillars = pilaresData.filter(p => centralPilar.connections.includes(p.id));
        const unconnectedPillars = pilaresData.filter(p => !centralPilar.connections.includes(p.id) && p.id !== centralPilar.id);

        const angleStepConnected = (2 * Math.PI) / connectedPillars.length;
        const radiusConnected = 220;
        connectedPillars.forEach((pilar, i) => {
            const angle = i * angleStepConnected - (Math.PI / 2);
            const x = centerX + radiusConnected * Math.cos(angle);
            const y = centerY + radiusConnected * Math.sin(angle);
            positions[pilar.id] = { x, y };
        });

        const angleStepUnconnected = (2 * Math.PI) / unconnectedPillars.length;
        const radiusUnconnected = 280;
        unconnectedPillars.forEach((pilar, i) => {
             const angle = i * angleStepUnconnected - (Math.PI / 2) + (angleStepUnconnected / 2);
             const x = centerX + radiusUnconnected * Math.cos(angle);
             const y = centerY + radiusUnconnected * Math.sin(angle);
             positions[pilar.id] = { x, y };
        });

        connectedPillars.forEach(pilar => {
            const pos = positions[pilar.id];
            drawLine(centerX, centerY, pos.x, pos.y);
        });
        
        pilaresData.forEach(pilar => {
            const textToShow = pilar.name.replace(' ', '\n');
            if (pilar.id === centralPilar.id) {
                drawNode(centerX, centerY, 55, pilar.color, textToShow, true, true);
            } else {
                 const pos = positions[pilar.id];
                 const isConnected = centralPilar.connections.includes(pilar.id);
                 drawNode(pos.x, pos.y, 40, pilar.color, textToShow, false, isConnected);
            }
        });
    }
</script>
</body>
</html>

