<!-- Chosen Palette: Indigo & Slate -->
<!-- Application Structure Plan: A single-purpose 2D canvas visualization tool. It's designed to generate a clear, focused network diagram for one central pillar and its direct connections. The central pillar is now defined by a URL parameter (e.g., "?pilar=2"), making the file dynamically reusable for all 10 pillars without code changes. If no parameter is provided, it defaults to pillar 1. This makes it ideal for linking from external documents. -->
<!-- Visualization & Content Choices: 
- Network Diagram -> Goal: Inform/Explain -> Method: 2D Canvas drawing -> Interaction: None (static image generation) -> Justification: Provides a simple, clear, and easily reproducible visual aid for documents. The dynamic nature comes from the URL, not from user interaction within the page itself.
-->
<!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizador de Interconexiones - ESTRATEGO SIG</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://rsms.me/inter/inter.css');
        body { font-family: 'Inter', sans-serif; background-color: #f8fafc; }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl bg-white p-6 rounded-xl shadow-lg text-center">
        <h1 id="diagram-title" class="text-2xl font-bold text-indigo-700 mb-2"></h1>
        <p class="text-slate-600 mb-4">Este diagrama muestra las conexiones directas del pilar central dentro del ecosistema ESTRATEGO SIG.</p>
        <canvas id="connection-canvas" width="800" height="600" class="mx-auto border rounded-lg"></canvas>
        <div id="instructions" class="mt-4 text-sm text-slate-500">
            <!-- Instructions will be populated by script -->
        </div>
    </div>

<script>
    // --- LÓGICA PARA LEER PARÁMETROS DE LA URL ---
    const urlParams = new URLSearchParams(window.location.search);
    const pilarIdFromUrl = parseInt(urlParams.get('pilar'), 10);
    
    // Si el parámetro 'pilar' existe en la URL y es un número válido (1-10), lo usamos. Si no, usamos 1 como valor por defecto.
    const centralPillarId = (pilarIdFromUrl >= 1 && pilarIdFromUrl <= 10) ? pilarIdFromUrl : 1;

    const pilaresData = [
        { id: 1, name: "Humano", color: "#22c55e", connections: [2, 6, 8, 4, 10] },
        { id: 2, name: "Procesos", color: "#3b82f6", connections: [1, 6, 8, 4] },
        { id: 3, name: "Personalización", color: "#a855f7", connections: [4, 5, 9] },
        { id: 4, name: "IA", color: "#ec4899", connections: [1, 2, 3, 6] },
        { id: 5, name: "Prospectivo", color: "#f59e0b", connections: [3, 7, 8, 9, 10] },
        { id: 6, name: "Operacional", color: "#14b8a6", connections: [1, 2, 7, 4] },
        { id: 7, name: "Planning", color: "#06b6d4", connections: [5, 6, 8] },
        { id: 8, name: "Project Mgmt", color: "#ef4444", connections: [1, 2, 5, 7, 9, 10] },
        { id: 9, name: "Cliente & Mercado", color: "#f472b6", connections: [3, 5, 8] },
        { id: 10, name: "Estrategias", color: "#84cc16", connections: [1, 5, 8] }
    ];

    const canvas = document.getElementById('connection-canvas');
    const ctx = canvas.getContext('2d');
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    const centralPilar = pilaresData.find(p => p.id === centralPillarId);
    if (centralPilar) {
        document.getElementById('diagram-title').textContent = `Mapa de Interconexión del Pilar: ${centralPilar.name}`;
        if (!pilarIdFromUrl) {
            document.getElementById('instructions').innerHTML = `<strong>Instrucción:</strong> Estás viendo el pilar por defecto. Para ver otro, añade <strong>?pilar=N</strong> al final de la URL (donde N es el número del pilar).`;
        }
        drawNetwork();
    }

    function drawNode(x, y, radius, color, text, isCentral = false, isConnected = false) {
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI, false);
        
        if (isCentral) {
            ctx.fillStyle = color;
            ctx.shadowColor = 'rgba(0,0,0,0.2)';
            ctx.shadowBlur = 15;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 5;
        } else if (isConnected) {
            ctx.fillStyle = color;
             ctx.shadowColor = 'rgba(0,0,0,0.1)';
            ctx.shadowBlur = 10;
        } else {
            ctx.fillStyle = '#e2e8f0';
        }
        
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.shadowColor = 'transparent';

        ctx.strokeStyle = isConnected || isCentral ? '#475569' : '#94a3b8';
        ctx.lineWidth = isCentral ? 4 : (isConnected ? 2 : 1);
        ctx.stroke();

        ctx.fillStyle = isCentral || isConnected ? 'white' : '#64748b';
        ctx.font = isCentral ? 'bold 16px Inter' : 'bold 14px Inter';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, x, y);
    }

    function drawLine(x1, y1, x2, y2) {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = '#94a3b8';
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    function drawNetwork() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const positions = {};
        const connectedPillars = pilaresData.filter(p => centralPilar.connections.includes(p.id));
        const unconnectedPillars = pilaresData.filter(p => !centralPilar.connections.includes(p.id) && p.id !== centralPilar.id);

        const angleStepConnected = (2 * Math.PI) / connectedPillars.length;
        const radiusConnected = 220;
        connectedPillars.forEach((pilar, i) => {
            const angle = i * angleStepConnected - (Math.PI / 2); // Start from top
            const x = centerX + radiusConnected * Math.cos(angle);
            const y = centerY + radiusConnected * Math.sin(angle);
            positions[pilar.id] = { x, y };
        });

        const angleStepUnconnected = (2 * Math.PI) / unconnectedPillars.length;
        const radiusUnconnected = 280;
        unconnectedPillars.forEach((pilar, i) => {
             const angle = i * angleStepUnconnected - (Math.PI / 2) + (angleStepUnconnected / 2); // Offset to fit between
             const x = centerX + radiusUnconnected * Math.cos(angle);
             const y = centerY + radiusUnconnected * Math.sin(angle);
             positions[pilar.id] = { x, y };
        });

        // Draw lines first
        connectedPillars.forEach(pilar => {
            const pos = positions[pilar.id];
            drawLine(centerX, centerY, pos.x, pos.y);
        });
        
        // Draw all nodes
        pilaresData.forEach(pilar => {
            if (pilar.id === centralPilar.id) {
                drawNode(centerX, centerY, 60, pilar.color, pilar.name, true, true);
            } else {
                 const pos = positions[pilar.id];
                 const isConnected = centralPilar.connections.includes(pilar.id);
                 drawNode(pos.x, pos.y, 45, pilar.color, pilar.name, false, isConnected);
            }
        });
    }
</script>
</body>
</html>

